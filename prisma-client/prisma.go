// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	if options != nil {
		endpoint = options.Endpoint
	}
	return &Client{
		Client: prisma.New(endpoint, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"

func (client *Client) Link(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"link",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

type LinksParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Links(params *LinksParams) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExecArray{ret}
}

type LinksConnectionParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) LinksConnection(params *LinksConnectionParams) LinkConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "name", "email", "password"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) Vote(params VoteWhereUniqueInput) *VoteExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"VoteWhereUniqueInput!", "Vote"},
		"vote",
		[]string{"id"})

	return &VoteExec{ret}
}

type VotesParams struct {
	Where   *VoteWhereInput   `json:"where,omitempty"`
	OrderBy *VoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Votes(params *VotesParams) *VoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"VoteWhereInput", "VoteOrderByInput", "Vote"},
		"votes",
		[]string{"id"})

	return &VoteExecArray{ret}
}

type VotesConnectionParams struct {
	Where   *VoteWhereInput   `json:"where,omitempty"`
	OrderBy *VoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) VotesConnection(params *VotesConnectionParams) VoteConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateLink(params LinkCreateInput) *LinkExec {
	ret := client.Client.Create(
		params,
		[2]string{"LinkCreateInput!", "Link"},
		"createLink",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

type LinkUpdateParams struct {
	Data  LinkUpdateInput      `json:"data"`
	Where LinkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLink(params LinkUpdateParams) *LinkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LinkUpdateInput!", "LinkWhereUniqueInput!", "Link"},
		"updateLink",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

type LinkUpdateManyParams struct {
	Data  LinkUpdateInput `json:"data"`
	Where *LinkWhereInput `json:"where,omitempty"`
}

func (client *Client) UpdateManyLinks(params LinkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LinkUpdateInput!", "LinkWhereInput"},
		"updateManyLinks")
	return &BatchPayloadExec{exec}
}

type LinkUpsertParams struct {
	Where  LinkWhereUniqueInput `json:"where"`
	Create LinkCreateInput      `json:"create"`
	Update LinkUpdateInput      `json:"update"`
}

func (client *Client) UpsertLink(params LinkUpsertParams) *LinkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LinkWhereUniqueInput!", "LinkCreateInput!", "LinkUpdateInput!", "Link"},
		"upsertLink",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

func (client *Client) DeleteLink(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"deleteLink",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

func (client *Client) DeleteManyLinks(params *LinkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LinkWhereInput", "deleteManyLinks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateInput `json:"data"`
	Where *UserWhereInput `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateVote(params VoteCreateInput) *VoteExec {
	ret := client.Client.Create(
		params,
		[2]string{"VoteCreateInput!", "Vote"},
		"createVote",
		[]string{"id"})

	return &VoteExec{ret}
}

type VoteUpdateParams struct {
	Data  VoteUpdateInput      `json:"data"`
	Where VoteWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateVote(params VoteUpdateParams) *VoteExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"VoteUpdateInput!", "VoteWhereUniqueInput!", "Vote"},
		"updateVote",
		[]string{"id"})

	return &VoteExec{ret}
}

type VoteUpdateManyParams struct {
	Data  VoteUpdateInput `json:"data"`
	Where *VoteWhereInput `json:"where,omitempty"`
}

func (client *Client) UpdateManyVotes(params VoteUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"VoteUpdateInput!", "VoteWhereInput"},
		"updateManyVotes")
	return &BatchPayloadExec{exec}
}

type VoteUpsertParams struct {
	Where  VoteWhereUniqueInput `json:"where"`
	Create VoteCreateInput      `json:"create"`
	Update VoteUpdateInput      `json:"update"`
}

func (client *Client) UpsertVote(params VoteUpsertParams) *VoteExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"VoteWhereUniqueInput!", "VoteCreateInput!", "VoteUpdateInput!", "Vote"},
		"upsertVote",
		[]string{"id"})

	return &VoteExec{ret}
}

func (client *Client) DeleteVote(params VoteWhereUniqueInput) *VoteExec {
	ret := client.Client.Delete(
		params,
		[2]string{"VoteWhereUniqueInput!", "Vote"},
		"deleteVote",
		[]string{"id"})

	return &VoteExec{ret}
}

func (client *Client) DeleteManyVotes(params *VoteWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "VoteWhereInput", "deleteManyVotes")
	return &BatchPayloadExec{exec}
}

type LinkOrderByInput string

const (
	LinkOrderByInputIDAsc           LinkOrderByInput = "id_ASC"
	LinkOrderByInputIDDesc          LinkOrderByInput = "id_DESC"
	LinkOrderByInputCreatedAtAsc    LinkOrderByInput = "createdAt_ASC"
	LinkOrderByInputCreatedAtDesc   LinkOrderByInput = "createdAt_DESC"
	LinkOrderByInputDescriptionAsc  LinkOrderByInput = "description_ASC"
	LinkOrderByInputDescriptionDesc LinkOrderByInput = "description_DESC"
	LinkOrderByInputUrlAsc          LinkOrderByInput = "url_ASC"
	LinkOrderByInputUrlDesc         LinkOrderByInput = "url_DESC"
	LinkOrderByInputUpdatedAtAsc    LinkOrderByInput = "updatedAt_ASC"
	LinkOrderByInputUpdatedAtDesc   LinkOrderByInput = "updatedAt_DESC"
)

type VoteOrderByInput string

const (
	VoteOrderByInputIDAsc         VoteOrderByInput = "id_ASC"
	VoteOrderByInputIDDesc        VoteOrderByInput = "id_DESC"
	VoteOrderByInputCreatedAtAsc  VoteOrderByInput = "createdAt_ASC"
	VoteOrderByInputCreatedAtDesc VoteOrderByInput = "createdAt_DESC"
	VoteOrderByInputUpdatedAtAsc  VoteOrderByInput = "updatedAt_ASC"
	VoteOrderByInputUpdatedAtDesc VoteOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc       UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc      UserOrderByInput = "name_DESC"
	UserOrderByInputEmailAsc      UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc     UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordAsc   UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc  UserOrderByInput = "password_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type LinkCreateManyWithoutPostedByInput struct {
	Create  []LinkCreateWithoutPostedByInput `json:"create,omitempty"`
	Connect []LinkWhereUniqueInput           `json:"connect,omitempty"`
}

type LinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserUpdateOneWithoutLinksInput struct {
	Create     *UserCreateWithoutLinksInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutLinksDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutLinksInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type LinkWhereInput struct {
	ID                       *string          `json:"id,omitempty"`
	IDNot                    *string          `json:"id_not,omitempty"`
	IDIn                     []string         `json:"id_in,omitempty"`
	IDNotIn                  []string         `json:"id_not_in,omitempty"`
	IDLt                     *string          `json:"id_lt,omitempty"`
	IDLte                    *string          `json:"id_lte,omitempty"`
	IDGt                     *string          `json:"id_gt,omitempty"`
	IDGte                    *string          `json:"id_gte,omitempty"`
	IDContains               *string          `json:"id_contains,omitempty"`
	IDNotContains            *string          `json:"id_not_contains,omitempty"`
	IDStartsWith             *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string          `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string          `json:"createdAt,omitempty"`
	CreatedAtNot             *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string          `json:"createdAt_gte,omitempty"`
	Description              *string          `json:"description,omitempty"`
	DescriptionNot           *string          `json:"description_not,omitempty"`
	DescriptionIn            []string         `json:"description_in,omitempty"`
	DescriptionNotIn         []string         `json:"description_not_in,omitempty"`
	DescriptionLt            *string          `json:"description_lt,omitempty"`
	DescriptionLte           *string          `json:"description_lte,omitempty"`
	DescriptionGt            *string          `json:"description_gt,omitempty"`
	DescriptionGte           *string          `json:"description_gte,omitempty"`
	DescriptionContains      *string          `json:"description_contains,omitempty"`
	DescriptionNotContains   *string          `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string          `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string          `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string          `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string          `json:"description_not_ends_with,omitempty"`
	Url                      *string          `json:"url,omitempty"`
	UrlNot                   *string          `json:"url_not,omitempty"`
	UrlIn                    []string         `json:"url_in,omitempty"`
	UrlNotIn                 []string         `json:"url_not_in,omitempty"`
	UrlLt                    *string          `json:"url_lt,omitempty"`
	UrlLte                   *string          `json:"url_lte,omitempty"`
	UrlGt                    *string          `json:"url_gt,omitempty"`
	UrlGte                   *string          `json:"url_gte,omitempty"`
	UrlContains              *string          `json:"url_contains,omitempty"`
	UrlNotContains           *string          `json:"url_not_contains,omitempty"`
	UrlStartsWith            *string          `json:"url_starts_with,omitempty"`
	UrlNotStartsWith         *string          `json:"url_not_starts_with,omitempty"`
	UrlEndsWith              *string          `json:"url_ends_with,omitempty"`
	UrlNotEndsWith           *string          `json:"url_not_ends_with,omitempty"`
	PostedBy                 *UserWhereInput  `json:"postedBy,omitempty"`
	AllVotesEvery            *VoteWhereInput  `json:"allVotes_every,omitempty"`
	AllVotesSome             *VoteWhereInput  `json:"allVotes_some,omitempty"`
	AllVotesNone             *VoteWhereInput  `json:"allVotes_none,omitempty"`
	And                      []LinkWhereInput `json:"AND,omitempty"`
	Or                       []LinkWhereInput `json:"OR,omitempty"`
	Not                      []LinkWhereInput `json:"NOT,omitempty"`
}

type UserUpdateWithoutLinksDataInput struct {
	Name     *string                            `json:"name,omitempty"`
	Email    *string                            `json:"email,omitempty"`
	Password *string                            `json:"password,omitempty"`
	Votes    *VoteUpdateManyWithoutVotedByInput `json:"votes,omitempty"`
}

type VoteWhereInput struct {
	ID              *string          `json:"id,omitempty"`
	IDNot           *string          `json:"id_not,omitempty"`
	IDIn            []string         `json:"id_in,omitempty"`
	IDNotIn         []string         `json:"id_not_in,omitempty"`
	IDLt            *string          `json:"id_lt,omitempty"`
	IDLte           *string          `json:"id_lte,omitempty"`
	IDGt            *string          `json:"id_gt,omitempty"`
	IDGte           *string          `json:"id_gte,omitempty"`
	IDContains      *string          `json:"id_contains,omitempty"`
	IDNotContains   *string          `json:"id_not_contains,omitempty"`
	IDStartsWith    *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string          `json:"id_not_ends_with,omitempty"`
	Link            *LinkWhereInput  `json:"link,omitempty"`
	VotedBy         *UserWhereInput  `json:"votedBy,omitempty"`
	And             []VoteWhereInput `json:"AND,omitempty"`
	Or              []VoteWhereInput `json:"OR,omitempty"`
	Not             []VoteWhereInput `json:"NOT,omitempty"`
}

type VoteCreateWithoutVotedByInput struct {
	Link LinkCreateOneWithoutAllVotesInput `json:"link"`
}

type VoteUpdateWithWhereUniqueWithoutLinkInput struct {
	Where VoteWhereUniqueInput           `json:"where"`
	Data  VoteUpdateWithoutLinkDataInput `json:"data"`
}

type LinkCreateOneWithoutAllVotesInput struct {
	Create  *LinkCreateWithoutAllVotesInput `json:"create,omitempty"`
	Connect *LinkWhereUniqueInput           `json:"connect,omitempty"`
}

type VoteUpdateManyWithoutVotedByInput struct {
	Create     []VoteCreateWithoutVotedByInput                `json:"create,omitempty"`
	Delete     []VoteWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []VoteWhereUniqueInput                         `json:"connect,omitempty"`
	Disconnect []VoteWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []VoteUpdateWithWhereUniqueWithoutVotedByInput `json:"update,omitempty"`
	Upsert     []VoteUpsertWithWhereUniqueWithoutVotedByInput `json:"upsert,omitempty"`
}

type LinkCreateWithoutAllVotesInput struct {
	Description string                          `json:"description"`
	Url         string                          `json:"url"`
	PostedBy    *UserCreateOneWithoutLinksInput `json:"postedBy,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type VoteCreateManyWithoutLinkInput struct {
	Create  []VoteCreateWithoutLinkInput `json:"create,omitempty"`
	Connect []VoteWhereUniqueInput       `json:"connect,omitempty"`
}

type VoteUpdateInput struct {
	Link    *LinkUpdateOneRequiredWithoutAllVotesInput `json:"link,omitempty"`
	VotedBy *UserUpdateOneRequiredWithoutVotesInput    `json:"votedBy,omitempty"`
}

type VoteCreateWithoutLinkInput struct {
	VotedBy UserCreateOneWithoutVotesInput `json:"votedBy"`
}

type UserUpdateInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkUpdateManyWithoutPostedByInput `json:"links,omitempty"`
	Votes    *VoteUpdateManyWithoutVotedByInput  `json:"votes,omitempty"`
}

type UserCreateOneWithoutVotesInput struct {
	Create  *UserCreateWithoutVotesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateInput struct {
	Name     string                              `json:"name"`
	Email    string                              `json:"email"`
	Password string                              `json:"password"`
	Links    *LinkCreateManyWithoutPostedByInput `json:"links,omitempty"`
	Votes    *VoteCreateManyWithoutVotedByInput  `json:"votes,omitempty"`
}

type UserCreateWithoutVotesInput struct {
	Name     string                              `json:"name"`
	Email    string                              `json:"email"`
	Password string                              `json:"password"`
	Links    *LinkCreateManyWithoutPostedByInput `json:"links,omitempty"`
}

type UserUpsertWithoutVotesInput struct {
	Update UserUpdateWithoutVotesDataInput `json:"update"`
	Create UserCreateWithoutVotesInput     `json:"create"`
}

type UserUpdateWithoutVotesDataInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkUpdateManyWithoutPostedByInput `json:"links,omitempty"`
}

type VoteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LinkCreateWithoutPostedByInput struct {
	Description string                          `json:"description"`
	Url         string                          `json:"url"`
	AllVotes    *VoteCreateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

type LinkUpdateWithWhereUniqueWithoutPostedByInput struct {
	Where LinkWhereUniqueInput               `json:"where"`
	Data  LinkUpdateWithoutPostedByDataInput `json:"data"`
}

type LinkUpdateInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserUpdateOneWithoutLinksInput `json:"postedBy,omitempty"`
	AllVotes    *VoteUpdateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

type UserCreateOneWithoutLinksInput struct {
	Create  *UserCreateWithoutLinksInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	Name                  *string          `json:"name,omitempty"`
	NameNot               *string          `json:"name_not,omitempty"`
	NameIn                []string         `json:"name_in,omitempty"`
	NameNotIn             []string         `json:"name_not_in,omitempty"`
	NameLt                *string          `json:"name_lt,omitempty"`
	NameLte               *string          `json:"name_lte,omitempty"`
	NameGt                *string          `json:"name_gt,omitempty"`
	NameGte               *string          `json:"name_gte,omitempty"`
	NameContains          *string          `json:"name_contains,omitempty"`
	NameNotContains       *string          `json:"name_not_contains,omitempty"`
	NameStartsWith        *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string          `json:"name_not_ends_with,omitempty"`
	Email                 *string          `json:"email,omitempty"`
	EmailNot              *string          `json:"email_not,omitempty"`
	EmailIn               []string         `json:"email_in,omitempty"`
	EmailNotIn            []string         `json:"email_not_in,omitempty"`
	EmailLt               *string          `json:"email_lt,omitempty"`
	EmailLte              *string          `json:"email_lte,omitempty"`
	EmailGt               *string          `json:"email_gt,omitempty"`
	EmailGte              *string          `json:"email_gte,omitempty"`
	EmailContains         *string          `json:"email_contains,omitempty"`
	EmailNotContains      *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string          `json:"email_not_ends_with,omitempty"`
	Password              *string          `json:"password,omitempty"`
	PasswordNot           *string          `json:"password_not,omitempty"`
	PasswordIn            []string         `json:"password_in,omitempty"`
	PasswordNotIn         []string         `json:"password_not_in,omitempty"`
	PasswordLt            *string          `json:"password_lt,omitempty"`
	PasswordLte           *string          `json:"password_lte,omitempty"`
	PasswordGt            *string          `json:"password_gt,omitempty"`
	PasswordGte           *string          `json:"password_gte,omitempty"`
	PasswordContains      *string          `json:"password_contains,omitempty"`
	PasswordNotContains   *string          `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string          `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string          `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string          `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string          `json:"password_not_ends_with,omitempty"`
	LinksEvery            *LinkWhereInput  `json:"links_every,omitempty"`
	LinksSome             *LinkWhereInput  `json:"links_some,omitempty"`
	LinksNone             *LinkWhereInput  `json:"links_none,omitempty"`
	VotesEvery            *VoteWhereInput  `json:"votes_every,omitempty"`
	VotesSome             *VoteWhereInput  `json:"votes_some,omitempty"`
	VotesNone             *VoteWhereInput  `json:"votes_none,omitempty"`
	And                   []UserWhereInput `json:"AND,omitempty"`
	Or                    []UserWhereInput `json:"OR,omitempty"`
	Not                   []UserWhereInput `json:"NOT,omitempty"`
}

type VoteCreateManyWithoutVotedByInput struct {
	Create  []VoteCreateWithoutVotedByInput `json:"create,omitempty"`
	Connect []VoteWhereUniqueInput          `json:"connect,omitempty"`
}

type UserUpdateOneRequiredWithoutVotesInput struct {
	Create  *UserCreateWithoutVotesInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutVotesDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutVotesInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type LinkSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *LinkWhereInput              `json:"node,omitempty"`
	And                        []LinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type VoteUpdateWithoutLinkDataInput struct {
	VotedBy *UserUpdateOneRequiredWithoutVotesInput `json:"votedBy,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type VoteUpdateWithWhereUniqueWithoutVotedByInput struct {
	Where VoteWhereUniqueInput              `json:"where"`
	Data  VoteUpdateWithoutVotedByDataInput `json:"data"`
}

type LinkUpsertWithWhereUniqueWithoutPostedByInput struct {
	Where  LinkWhereUniqueInput               `json:"where"`
	Update LinkUpdateWithoutPostedByDataInput `json:"update"`
	Create LinkCreateWithoutPostedByInput     `json:"create"`
}

type VoteUpdateWithoutVotedByDataInput struct {
	Link *LinkUpdateOneRequiredWithoutAllVotesInput `json:"link,omitempty"`
}

type LinkUpdateManyWithoutPostedByInput struct {
	Create     []LinkCreateWithoutPostedByInput                `json:"create,omitempty"`
	Delete     []LinkWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []LinkWhereUniqueInput                          `json:"connect,omitempty"`
	Disconnect []LinkWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []LinkUpdateWithWhereUniqueWithoutPostedByInput `json:"update,omitempty"`
	Upsert     []LinkUpsertWithWhereUniqueWithoutPostedByInput `json:"upsert,omitempty"`
}

type LinkUpdateOneRequiredWithoutAllVotesInput struct {
	Create  *LinkCreateWithoutAllVotesInput     `json:"create,omitempty"`
	Update  *LinkUpdateWithoutAllVotesDataInput `json:"update,omitempty"`
	Upsert  *LinkUpsertWithoutAllVotesInput     `json:"upsert,omitempty"`
	Connect *LinkWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutLinksInput struct {
	Name     string                             `json:"name"`
	Email    string                             `json:"email"`
	Password string                             `json:"password"`
	Votes    *VoteCreateManyWithoutVotedByInput `json:"votes,omitempty"`
}

type LinkUpdateWithoutAllVotesDataInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserUpdateOneWithoutLinksInput `json:"postedBy,omitempty"`
}

type VoteCreateInput struct {
	Link    LinkCreateOneWithoutAllVotesInput `json:"link"`
	VotedBy UserCreateOneWithoutVotesInput    `json:"votedBy"`
}

type VoteUpdateManyWithoutLinkInput struct {
	Create     []VoteCreateWithoutLinkInput                `json:"create,omitempty"`
	Delete     []VoteWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []VoteWhereUniqueInput                      `json:"connect,omitempty"`
	Disconnect []VoteWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []VoteUpdateWithWhereUniqueWithoutLinkInput `json:"update,omitempty"`
	Upsert     []VoteUpsertWithWhereUniqueWithoutLinkInput `json:"upsert,omitempty"`
}

type UserUpsertWithoutLinksInput struct {
	Update UserUpdateWithoutLinksDataInput `json:"update"`
	Create UserCreateWithoutLinksInput     `json:"create"`
}

type VoteUpsertWithWhereUniqueWithoutVotedByInput struct {
	Where  VoteWhereUniqueInput              `json:"where"`
	Update VoteUpdateWithoutVotedByDataInput `json:"update"`
	Create VoteCreateWithoutVotedByInput     `json:"create"`
}

type LinkUpsertWithoutAllVotesInput struct {
	Update LinkUpdateWithoutAllVotesDataInput `json:"update"`
	Create LinkCreateWithoutAllVotesInput     `json:"create"`
}

type VoteUpsertWithWhereUniqueWithoutLinkInput struct {
	Where  VoteWhereUniqueInput           `json:"where"`
	Update VoteUpdateWithoutLinkDataInput `json:"update"`
	Create VoteCreateWithoutLinkInput     `json:"create"`
}

type VoteSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *VoteWhereInput              `json:"node,omitempty"`
	And                        []VoteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []VoteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []VoteSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkCreateInput struct {
	Description string                          `json:"description"`
	Url         string                          `json:"url"`
	PostedBy    *UserCreateOneWithoutLinksInput `json:"postedBy,omitempty"`
	AllVotes    *VoteCreateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

type LinkUpdateWithoutPostedByDataInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	AllVotes    *VoteUpdateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

type VotePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance VotePreviousValuesExec) Exec(ctx context.Context) (*VotePreviousValues, error) {
	var v VotePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VotePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VotePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance VotePreviousValuesExecArray) Exec(ctx context.Context) ([]VotePreviousValues, error) {
	var v []VotePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VotePreviousValues struct {
	ID string `json:"id"`
}

type VoteExec struct {
	exec *prisma.Exec
}

func (instance *VoteExec) Link() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"link",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

func (instance *VoteExec) VotedBy() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"votedBy",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

func (instance VoteExec) Exec(ctx context.Context) (*Vote, error) {
	var v Vote
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VoteExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VoteExecArray struct {
	exec *prisma.Exec
}

func (instance VoteExecArray) Exec(ctx context.Context) ([]Vote, error) {
	var v []Vote
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Vote struct {
	ID string `json:"id"`
}

type LinkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LinkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LinkConnectionExec) Edges() *LinkEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkEdge"},
		"edges",
		[]string{"cursor"})

	return &LinkEdgeExec{ret}
}

func (instance *LinkConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLink"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance LinkConnectionExec) Exec(ctx context.Context) (*LinkConnection, error) {
	var v LinkConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LinkConnectionExecArray) Exec(ctx context.Context) ([]LinkConnection, error) {
	var v []LinkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkConnection struct {
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type UserExec struct {
	exec *prisma.Exec
}

type LinksParamsExec struct {
	Where   *LinkWhereInput
	OrderBy *LinkOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Links(params *LinksParamsExec) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExecArray{ret}
}

type VotesParamsExec struct {
	Where   *VoteWhereInput
	OrderBy *VoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Votes(params *VotesParamsExec) *VoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"VoteWhereInput", "VoteOrderByInput", "Vote"},
		"votes",
		[]string{"id"})

	return &VoteExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type LinkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LinkEdgeExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

func (instance LinkEdgeExec) Exec(ctx context.Context) (*LinkEdge, error) {
	var v LinkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LinkEdgeExecArray) Exec(ctx context.Context) ([]LinkEdge, error) {
	var v []LinkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkEdge struct {
	Cursor string `json:"cursor"`
}

type VoteConnectionExec struct {
	exec *prisma.Exec
}

func (instance *VoteConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *VoteConnectionExec) Edges() *VoteEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "VoteEdge"},
		"edges",
		[]string{"cursor"})

	return &VoteEdgeExec{ret}
}

func (instance *VoteConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateVote"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance VoteConnectionExec) Exec(ctx context.Context) (*VoteConnection, error) {
	var v VoteConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VoteConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VoteConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance VoteConnectionExecArray) Exec(ctx context.Context) ([]VoteConnection, error) {
	var v []VoteConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VoteConnection struct {
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "name", "email", "password"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type LinkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExec) Exec(ctx context.Context) (*LinkPreviousValues, error) {
	var v LinkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExecArray) Exec(ctx context.Context) ([]LinkPreviousValues, error) {
	var v []LinkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkPreviousValues struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Description string `json:"description"`
	Url         string `json:"url"`
}

type LinkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LinkSubscriptionPayloadExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkExec{ret}
}

func (instance *LinkSubscriptionPayloadExec) PreviousValues() *LinkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "description", "url"})

	return &LinkPreviousValuesExec{ret}
}

func (instance LinkSubscriptionPayloadExec) Exec(ctx context.Context) (*LinkSubscriptionPayload, error) {
	var v LinkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LinkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LinkSubscriptionPayload, error) {
	var v []LinkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LinkSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type LinkExec struct {
	exec *prisma.Exec
}

func (instance *LinkExec) PostedBy() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"postedBy",
		[]string{"id", "name", "email", "password"})

	return &UserExec{ret}
}

type AllVotesParamsExec struct {
	Where   *VoteWhereInput
	OrderBy *VoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LinkExec) AllVotes(params *AllVotesParamsExec) *VoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"VoteWhereInput", "VoteOrderByInput", "Vote"},
		"allVotes",
		[]string{"id"})

	return &VoteExecArray{ret}
}

func (instance LinkExec) Exec(ctx context.Context) (*Link, error) {
	var v Link
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkExecArray struct {
	exec *prisma.Exec
}

func (instance LinkExecArray) Exec(ctx context.Context) ([]Link, error) {
	var v []Link
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Link struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Description string `json:"description"`
	Url         string `json:"url"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type VoteSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *VoteSubscriptionPayloadExec) Node() *VoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Vote"},
		"node",
		[]string{"id"})

	return &VoteExec{ret}
}

func (instance *VoteSubscriptionPayloadExec) PreviousValues() *VotePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "VotePreviousValues"},
		"previousValues",
		[]string{"id"})

	return &VotePreviousValuesExec{ret}
}

func (instance VoteSubscriptionPayloadExec) Exec(ctx context.Context) (*VoteSubscriptionPayload, error) {
	var v VoteSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VoteSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VoteSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance VoteSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]VoteSubscriptionPayload, error) {
	var v []VoteSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VoteSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type VoteEdgeExec struct {
	exec *prisma.Exec
}

func (instance *VoteEdgeExec) Node() *VoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Vote"},
		"node",
		[]string{"id"})

	return &VoteExec{ret}
}

func (instance VoteEdgeExec) Exec(ctx context.Context) (*VoteEdge, error) {
	var v VoteEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VoteEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VoteEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance VoteEdgeExecArray) Exec(ctx context.Context) ([]VoteEdge, error) {
	var v []VoteEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VoteEdge struct {
	Cursor string `json:"cursor"`
}
